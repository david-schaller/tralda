"""Script for benchmarking the supertree construction algorithms."""

from __future__ import annotations

import itertools
from pathlib import Path
import random
from time import time
from typing import Any

from tralda.datastructures import Tree
from tralda.supertree import Build
from tralda.supertree import build_st
from tralda.supertree import linear_common_refinement
from tralda.supertree import loose_consensus_tree
from tralda.supertree import merge_all
from tralda.supertree import tree_profile_to_triples


PATH_RESULT_DIR = Path(__file__).parent / "results"
PATH_OUTPUT_FILE = PATH_RESULT_DIR / "benchmark.csv"

NUM_LEAVES_VALUES = [10, 20, 40, 80, 160, 320, 640]
NUM_SUBTREES_VALUES = [2, 8, 32]
CONRACTION_PROBABILITY_VALUES = [0.1, 0.5, 0.9]
REPETITIONS = 100

HEADER = [
    "sim_id",
    "repetition",
    "num_leaves",
    "num_subtrees",
    "contraction_probability",
    "inner_vertices_orig",
    "inner_vertices_mean",
    "inner_vertices_classic_build",
    "inner_vertices_buildst",
    "inner_vertices_lincr",
    "inner_vertices_merge_trees",
    "inner_vertices_lct",
    "success_classic_build",
    "success_buildst",
    "success_lincr",
    "time_triples",
    "time_classic_build",
    "time_buildst",
    "time_lincr",
    "time_merge_trees",
    "time_lct",
    "classic_build_vs_buildst",
    "classic_build_vs_lincr",
    "buildst_vs_lincr",
    "classic_build_vs_merge_trees",
    "classic_build_vs_lct",
    "orig_vs_lincr",
    "orig_refines_lincr",
]


def write_line(path: Path, line: list[Any], append: bool = True) -> None:
    """Write a line in the output file.

    Args:
        path: The file path.
        line: The list of values to write.
        append: Whether to append the line if the file already exists.
    """
    mode = "a" if append else "w"
    with open(path, mode) as f:
        f.write(",".join(str(item) for item in line))
        f.write("\n")


def simulation(
    sim_id: int,
    repetition: int,
    num_leaves: int,
    num_subtrees: int,
    contraction_probability: float,
) -> list[Any]:
    """Simulate trees and compare algorithms for constructing the supertree.

    The function first generated a random tree. From this tree, a number of less-resolved trees are
    generated by random contraction of inner edges. The resulting profile of trees is therefore
    guranateed to be compatible.
    Then different algorithms for supertree construction are run and the resulting supertrees are
    compared.

    Args:
        sim_id: A unique simulation ID.
        repetition: The repetition of the parameter combination.
        num_leaves: The number of leaves of the tree to simulate.
        num_subtrees: The number of less-resolved trees to construct from the original random tree.
        contraction_probability: The probability that an individual ineer edge gets contracted.

    Returns:
        A list of results.
    """
    # simulate a random tree
    tree = Tree.random_tree(num_leaves)
    inner_vertices_orig = sum(1 for _ in tree.inner_nodes())

    # construct less resolved trees by contraction of inner edges
    trees = []
    trees_inner_vertices = []
    for _ in range(num_subtrees):
        tree_i = tree.copy()

        edges = []

        for u, v in tree_i.inner_edges():
            if random.random() < contraction_probability:
                edges.append((u, v))

        tree_i.contract(edges)
        trees.append(tree_i)
        trees_inner_vertices.append(sum(1 for _ in tree_i.inner_nodes()))

    # classic BUILD algorithm (Aho et al. 1981)
    start_time = time()
    leaves, triples = tree_profile_to_triples(trees)
    time_triples = time() - start_time
    build = Build(triples, leaves, mincut=False)
    tree_classic_build = build.build_tree()
    time_classic_build = time() - start_time

    # BuildST algorithm (Deng and FernÃ¡ndez-Baca 2018)
    start_time = time()
    tree_buildst = build_st(trees)
    time_buildst = time() - start_time

    # LinCR / linear common refinement algorithm (Schaller et al. 2021)
    start_time = time()
    tree_lincr = linear_common_refinement(trees)
    time_lincr = time() - start_time

    # Merge Trees (Jansson et al. 2018)
    start_time = time()
    tree_merge_trees = merge_all(trees)
    time_merge_trees = time() - start_time

    # loose consensus tree (Jansson et al. 2018)
    start_time = time()
    tree_lct = loose_consensus_tree(trees)
    time_lct = time() - start_time

    # compare the tree topologies (should be the same for all constructed supertrees)

    if tree_classic_build and tree_buildst:
        classic_build_vs_buildst = tree_classic_build.equal_topology(tree_buildst)
    elif not tree_classic_build and not tree_buildst:
        classic_build_vs_buildst = True
    else:
        classic_build_vs_buildst = False

    if tree_classic_build and tree_lincr:
        classic_build_vs_lincr = tree_classic_build.equal_topology(tree_lincr)
    elif not tree_classic_build and not tree_lincr:
        classic_build_vs_lincr = True
    else:
        classic_build_vs_lincr = False

    if tree_buildst and tree_lincr:
        buildst_vs_lincr = tree_buildst.equal_topology(tree_lincr)
    elif not tree_buildst and not tree_lincr:
        buildst_vs_lincr = True
    else:
        buildst_vs_lincr = False

    if tree_classic_build and tree_merge_trees:
        classic_build_vs_merge_trees = tree_classic_build.equal_topology(tree_merge_trees)
    elif not tree_classic_build and not tree_merge_trees:
        classic_build_vs_merge_trees = True
    else:
        classic_build_vs_merge_trees = False

    if tree_classic_build and tree_lct:
        classic_build_vs_lct = tree_classic_build.equal_topology(tree_lct)
    elif not tree_classic_build and not tree_lct:
        classic_build_vs_lct = True
    else:
        classic_build_vs_lct = False

    if tree_lincr:
        orig_vs_lincr = tree.equal_topology(tree_lincr)
        orig_refines_lincr = tree.is_refinement(tree_lincr)

    return [
        sim_id,
        repetition,
        num_leaves,
        num_subtrees,
        contraction_probability,
        inner_vertices_orig,
        sum(trees_inner_vertices) / num_subtrees,
        sum(1 for _ in tree_classic_build.inner_nodes()) if tree_classic_build else float("nan"),
        sum(1 for _ in tree_buildst.inner_nodes()) if tree_buildst else float("nan"),
        sum(1 for _ in tree_lincr.inner_nodes()) if tree_lincr else float("nan"),
        sum(1 for _ in tree_merge_trees.inner_nodes()) if tree_merge_trees else float("nan"),
        sum(1 for _ in tree_lct.inner_nodes()) if tree_lct else float("nan"),
        bool(tree_classic_build),
        bool(tree_buildst),
        bool(tree_lincr),
        time_triples,
        time_classic_build,
        time_buildst,
        time_lincr,
        time_merge_trees,
        time_lct,
        classic_build_vs_buildst,
        classic_build_vs_lincr,
        buildst_vs_lincr,
        classic_build_vs_merge_trees,
        classic_build_vs_lct,
        orig_vs_lincr,
        orig_refines_lincr,
    ]


if __name__ == "__main__":
    PATH_RESULT_DIR.mkdir(exist_ok=True)

    write_line(PATH_OUTPUT_FILE, HEADER, append=False)

    for sim_id, (repetition, num_leaves, num_subtrees, contraction_probability) in enumerate(
        itertools.product(
            range(REPETITIONS),
            NUM_LEAVES_VALUES,
            NUM_SUBTREES_VALUES,
            CONRACTION_PROBABILITY_VALUES,
        )
    ):
        print(
            f"sim_id {sim_id}, "
            f"rep. {repetition + 1}/{REPETITIONS}, "
            f"leaves: {num_leaves}, subtrees: {num_subtrees}, "
            f"contraction prob.: {contraction_probability}"
        )
        line = simulation(sim_id, repetition, num_leaves, num_subtrees, contraction_probability)
        write_line(PATH_OUTPUT_FILE, line)
